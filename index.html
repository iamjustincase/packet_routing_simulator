<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Packet Routing Simulator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
        }
        .control-panel, .info-panel {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        .control-panel {
            overflow-y: auto;
        }
        #network-diagram-container svg {
            width: 100%;
            height: auto;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background-color: #fdfdfd; /* A very light off-white for the background */
            cursor: grab;
        }
        pre {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ced4da;
            max-height: 250px;
            overflow-y: auto;
        }
        h1, h2, h3, h4 {
            font-weight: 300;
        }
        h1 {
            color: #007bff;
        }
        .form-label {
            font-weight: 500;
        }
        .accordion-button {
            font-weight: 500 !important;
        }
        /* Style for labels */
        .cost-label, .packet-label {
            font-size: 10px;
            font-weight: bold;
            pointer-events: none;
        }
        .cost-label {
            text-anchor: middle;
            dominant-baseline: central;
        }
        .cost-label-halo {
            fill: none;
            stroke: white;
            stroke-width: 3px;
            stroke-linejoin: round;
        }
        .cost-label-text {
            fill: #333;
        }
        .packet-label {
            fill: #333;
            text-anchor: start;
            dominant-baseline: middle;
        }
    </style>
</head>

<body>
    <main class="container-fluid my-4">
        <div class="text-center mb-4">
            <h1>Packet Routing Simulator</h1>
            <p class="lead">A simplified demonstration of packet routing in a Software-Defined Network (SDN).</p>
            <p class="text-muted small">
                <a href="#" class="link-secondary text-decoration-none">Armaan Z. Hussain</a> &middot;
                <a href="#" class="link-secondary text-decoration-none">Lakshya Dubey</a> &middot;
                <a href="#" class="link-secondary text-decoration-none">Kannabiran</a> &middot;
                <a href="#" class="link-secondary text-decoration-none">Pranav Ranjan</a>
            </p>
        </div>

        <div class="row g-4">
            <div class="col-lg-7">
                <div id="network-diagram-container" class="info-panel">
                </div>
                <div class="info-panel mt-4">
                    <h3>Documentation</h3>
                    <div class="accordion" id="documentationAccordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button" type="button" data-bs-toggle="collapse"
                                    data-bs-target="#collapseGuide" aria-expanded="true" aria-controls="collapseGuide">
                                    Simulator Guide
                                </button>
                            </h2>
                            <div id="collapseGuide" class="accordion-collapse collapse show"
                                data-bs-parent="#documentationAccordion">
                                <div class="accordion-body">
                                    <h6>1. Define Network Edges</h6>
                                    <p>
                                        The text area allows you to define the network's structure in the format
                                        <code>Source,Destination,Cost</code>. The visualization will update
                                        dynamically as you type. You can <strong>click and drag routers</strong> to organize the layout.
                                    </p>

                                    <h6>2. Send a Packet</h6>
                                    <p>Enter the start and end routers. You can also set the packet's <strong>Time-To-Live (TTL)</strong>, which is the maximum number of hops it can make before being dropped.</p>

                                    <h6>3. Control Simulation</h6>
                                    <ul>
                                        <li><strong>Reset Simulation:</strong> Clears all packets and resets the simulation.</li>
                                        <li><strong>Zoom Buttons (+/-):</strong> Use these or your mouse wheel to zoom and pan.</li>
                                        <li><strong>Speed Slider:</strong> Controls the animation speed.</li>
                                    </ul>

                                    <h6>4. The Visualization</h6>
                                    <ul>
                                        <li><span class="badge" style="background-color: #ff9800;">Orange</span>: Queued Packet</li>
                                        <li><span class="badge" style="background-color: #e67e22;">Dark Orange</span>: In-Transit Packet</li>
                                        <li><span class="badge" style="background-color: #2ecc71;">Green</span>: Arrived Packet</li>
                                         <li><span class="badge" style="background-color: #e74c3c;">Red</span>: Dropped Packet (TTL Expired)</li>
                                    </ul>

                                    <h6>5. Forwarding Table</h6>
                                    <p>Select a router to inspect its forwarding table, which is calculated by the central controller using Dijkstra's algorithm.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-lg-5">
                <div class="control-panel">
                    <div class="mb-4">
                        <label for="edgeInput" class="form-label">
                            <h4>1. Define Network Edges</h4>
                        </label>
                        <textarea id="edgeInput" class="form-control" rows="7">A,B,4
A,C,2
B,D,5
C,D,8
D,E,2
D,F,6
E,F,3</textarea>
                        <div class="form-text">Enter edges as `Source,Destination,Cost` on separate lines.</div>
                    </div>

                    <div class="mb-4">
                        <h4>2. Send a Packet</h4>
                        <form id="packet-form" class="row g-2 align-items-end">
                            <div class="col-auto">
                                <label for="source-node" class="form-label">Source</label>
                                <input type="text" id="source-node" class="form-control" value="A" style="width: 70px;">
                            </div>
                            <div class="col-auto">
                                <label for="dest-node" class="form-label">Destination</label>
                                <input type="text" id="dest-node" class="form-control" value="F" style="width: 70px;">
                            </div>
                            <div class="col-auto">
                                <label for="ttl-input" class="form-label">TTL</label>
                                <input type="number" id="ttl-input" class="form-control" value="10" min="1" max="255" style="width: 70px;">
                            </div>
                            <div class="col-auto">
                                <button type="submit" class="btn btn-primary">Send</button>
                            </div>
                        </form>
                    </div>

                    <div class="mb-4">
                        <h4>3. Control Simulation</h4>
                        <div class="d-flex align-items-center">
                            <button id="resetButton" class="btn btn-danger me-2">Reset</button>
                            <div class="btn-group me-3" role="group">
                                <button id="zoomOutBtn" type="button" class="btn btn-secondary">-</button>
                                <button id="zoomInBtn" type="button" class="btn btn-secondary">+</button>
                            </div>
                            <label for="simulationSpeed" class="form-label me-2 mb-0 text-nowrap">Simulation second <br>tick (100ms - 2000ms):</label>
                            <input type="range" id="simulationSpeed" class="form-range" min="100" max="2000" step="100" value="100">
                        </div>
                    </div>

                    <div class="mb-4">
                        <h4>4. Forwarding Table</h4>
                        <div class="input-group">
                            <label class="input-group-text" for="selectedRouter">Inspect Router:</label>
                            <select id="selectedRouter" class="form-select"></select>
                        </div>
                        <pre id="forwarding-table-display" class="mt-2">{}</pre>
                    </div>

                </div>
            </div>
        </div>
    </main>

    <footer class="text-center mt-5 py-4 border-top">
        <div class="container">
            <p class="text-muted mb-1">Developed by <strong>Group 6 (IIIT Kottayam)</strong></p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- CLASSES ---
        class Packet {
            constructor(src, dst, pkt_id, ttl = 64) {
                this.src = src; this.dst = dst; this.pkt_id = pkt_id;
                this.path = []; this.ttl = ttl; this.status = 'active';
            }
            decrementTTL() { this.ttl--; return this.ttl >= 0; }
        }

        class Router {
            constructor(id) {
                this.id = id; this.packetQueue = []; this.forwardingTable = {}; this.neighbors = new Map();
            }
            receivePacket(packet) { this.packetQueue.push(packet); }
            setForwardingTable(table) { this.forwardingTable = table; }
            // --- BUG FIX: Corrected TTL and arrival logic ---
            processQueue() {
                if (this.packetQueue.length === 0) return null;
                const packet = this.packetQueue.shift();

                // 1. Check for arrival FIRST. A packet at its destination is not forwarded, so TTL is not decremented.
                if (this.id === packet.dst) {
                    return { packet, status: 'arrived' };
                }

                // 2. If it's not the destination, it's a "hop". Decrement TTL.
                if (!packet.decrementTTL()) {
                    // TTL has expired. Drop the packet.
                    return { packet, status: 'dropped' };
                }
                
                // 3. TTL is okay. Find the next hop for forwarding.
                const nextHopId = this.forwardingTable[packet.dst];
                if (nextHopId) {
                    return { packet, status: 'forward', nextHopId, cost: this.neighbors.get(nextHopId) };
                }
                
                // 4. No route found. Drop the packet.
                return { packet, status: 'dropped' };
            }
        }

        class Network {
            constructor() { this.routers = new Map(); }
            addRouter(routerId) { this.routers.set(routerId, new Router(routerId)); }
            getRouter(routerId) { return this.routers.get(routerId); }
            addEdge(routerId1, routerId2, cost) {
                const router1 = this.getRouter(routerId1);
                const router2 = this.getRouter(routerId2);
                if (router1 && router2) {
                    router1.neighbors.set(routerId2, cost);
                    router2.neighbors.set(routerId1, cost);
                }
            }
            dijkstra(startId) {
                const costs = {}; const predecessors = {}; const visited = new Set();
                const pq = new Map();
                for (const routerId of this.routers.keys()) {
                    costs[routerId] = Infinity; predecessors[routerId] = null;
                }
                costs[startId] = 0; pq.set(startId, 0);
                while (pq.size > 0) {
                    const currentId = [...pq.entries()].sort((a, b) => a[1] - b[1])[0][0];
                    pq.delete(currentId);
                    if (visited.has(currentId)) continue;
                    visited.add(currentId);
                    const currentRouter = this.getRouter(currentId);
                    for (const [neighborId, cost] of currentRouter.neighbors.entries()) {
                        const newCost = costs[currentId] + cost;
                        if (newCost < costs[neighborId]) {
                            costs[neighborId] = newCost; predecessors[neighborId] = currentId; pq.set(neighborId, newCost);
                        }
                    }
                }
                const allPaths = {};
                for (const routerId of this.routers.keys()) {
                    let path = []; let current = routerId;
                    while (current !== null) { path.unshift(current); current = predecessors[current]; }
                    if (path[0] === startId) { allPaths[routerId] = { path, cost: costs[routerId] }; }
                }
                return allPaths;
            }
            computeAllPaths() {
                for (const routerId of this.routers.keys()) {
                    const paths = this.dijkstra(routerId);
                    const forwardingTable = {};
                    for (const destId in paths) {
                        if (destId !== routerId && paths[destId].path.length > 1) {
                            forwardingTable[destId] = paths[destId].path[1];
                        }
                    }
                    this.getRouter(routerId).setForwardingTable(forwardingTable);
                }
            }
        }
        
        let network = new Network();
        let simulationState = getInitialState();
        let simulationInterval = null;
        const edgeInput = document.getElementById('edgeInput');
        const packetForm = document.getElementById('packet-form');
        const sourceNodeInput = document.getElementById('source-node');
        const destNodeInput = document.getElementById('dest-node');
        const ttlInput = document.getElementById('ttl-input');
        const resetButton = document.getElementById('resetButton');
        const speedSlider = document.getElementById('simulationSpeed');
        const routerSelect = document.getElementById('selectedRouter');
        const tableDisplay = document.getElementById('forwarding-table-display');
        const vizContainer = document.getElementById('network-diagram-container');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        
        const width = 650, height = 450, routerRadius = 20, packetRadius = 8;
        let nodes = [], links = [];

        const svg = d3.select(vizContainer).append("svg").attr("viewBox", `0 0 ${width} ${height}`);
        
        const defs = svg.append("defs");
        const gridPattern = defs.append("pattern")
            .attr("id", "grid-pattern")
            .attr("width", 20).attr("height", 20)
            .attr("patternUnits", "userSpaceOnUse");
        gridPattern.append("path")
            .attr("d", "M 20 0 L 0 0 0 20")
            .attr("fill", "none").attr("stroke", "#e9ecef").attr("stroke-width", 1);
        svg.append("rect")
            .attr("width", "100%").attr("height", "100%")
            .attr("fill", "url(#grid-pattern)");
            
        const container = svg.append("g");
        
        let linkElements = container.append("g").attr("class", "links").selectAll(".link");
        let nodeElements = container.append("g").attr("class", "nodes").selectAll(".node");
        let costElements = container.append("g").attr("class", "costs").selectAll(".cost-label");
        let packetElements = container.append("g").attr("class", "packets");
        
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(120))
            .force("charge", d3.forceManyBody().strength(-500))
            .force("center", d3.forceCenter(width / 2, height / 2));
        
        simulation.on("tick", () => {
            nodeElements.attr("transform", d => `translate(${d.x},${d.y})`);
            linkElements
                .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
            costElements
                .attr("transform", d => `translate(${(d.source.x + d.target.x) / 2}, ${(d.source.y + d.target.y) / 2})`);
        });

        const zoom = d3.zoom().scaleExtent([0.2, 5]).on("zoom", (event) => {
            container.attr("transform", event.transform);
        });
        svg.call(zoom);

        function getInitialState() {
            return { activePackets: new Map(), packetsInTransit: [], packetCounter: 0, tickCounter: 0 };
        }

        function updateNetworkFromInput() {
            const edgeText = edgeInput.value.trim();
            const edgeLines = edgeText.split('\n').map(line => line.split(','));
            const newLinks = [];
            const nodeIds = new Set();

            for (const [source, dest, costStr] of edgeLines) {
                if (source && dest && costStr) {
                    const s = source.trim(); const d = dest.trim(); const c = parseInt(costStr, 10);
                    if (s && d && !isNaN(c)) {
                        newLinks.push({ source: s, target: d, cost: c });
                        nodeIds.add(s); nodeIds.add(d);
                    }
                }
            }
            const newNodes = Array.from(nodeIds).map(id => {
                const existing = nodes.find(n => n.id === id);
                return existing || { id, x: width / 2, y: height / 2 };
            });
            nodes = newNodes;
            links = newLinks;
            
            network = new Network();
            nodes.forEach(node => network.addRouter(node.id));
            links.forEach(link => network.addEdge(link.source, link.target, link.cost));
            network.computeAllPaths();
            
            updateD3Graph();
            updateRouterSelect();
        }

        function updateD3Graph() {
            nodeElements = nodeElements.data(nodes, d => d.id).join(
                enter => {
                    const nodeGroup = enter.append("g").attr("class", "node").call(drag(simulation));
                    nodeGroup.append("circle").attr("r", routerRadius).attr("fill", "steelblue");
                    nodeGroup.append("text").text(d => d.id)
                        .attr("text-anchor", "middle").attr("dominant-baseline", "central")
                        .attr("fill", "white").attr("font-weight", "bold");
                    return nodeGroup;
                }
            );

            linkElements = linkElements.data(links, d => `${d.source.id}-${d.target.id}`).join("line")
                .attr("class", "link").attr("stroke", "#999").attr("stroke-opacity", 0.6).attr("stroke-width", 2);
            
            costElements = costElements.data(links, d => `${d.source.id}-${d.target.id}`).join(
                enter => {
                    const group = enter.append("g").attr("class", "cost-label");
                    group.append("text").attr("class", "cost-label-halo").text(d => d.cost);
                    group.append("text").attr("class", "cost-label-text").text(d => d.cost);
                    return group;
                }
            );

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }

        function resetSimulation() {
            simulationState = getInitialState();
            updateNetworkFromInput();
            renderPackets();
        }
        
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
            }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null; d.fy = null;
            }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // --- SIMULATION ENGINE ---
        function simulationTick() {
            const now = ++simulationState.tickCounter;

            // --- BUG FIX: New logic to clean up dropped packets after a delay ---
            for (const [id, packet] of simulationState.activePackets.entries()) {
                if (packet.status === 'dropped' && now >= packet.removalTick) {
                    simulationState.activePackets.delete(id);
                }
            }

            const stillInTransit = [];
            for (const transit of simulationState.packetsInTransit) {
                if (now >= transit.arrivalTime) {
                    if (transit.packet.path[transit.packet.path.length - 1] !== transit.nextHopId) {
                         transit.packet.path.push(transit.nextHopId);
                    }
                    network.getRouter(transit.nextHopId)?.receivePacket(transit.packet);
                } else { stillInTransit.push(transit); }
            }
            simulationState.packetsInTransit = stillInTransit;

            network.routers.forEach(router => {
                const decision = router.processQueue();
                if (decision) {
                    if (decision.status === 'forward') {
                        decision.packet.path.push(router.id);
                        simulationState.packetsInTransit.push({
                            packet: decision.packet, nextHopId: decision.nextHopId,
                            departureTime: now, arrivalTime: now + decision.cost,
                        });
                    } else if (decision.status === 'arrived') {
                        decision.packet.status = 'arrived';
                        if (decision.packet.path[decision.packet.path.length - 1] !== router.id) {
                            decision.packet.path.push(router.id);
                        }
                    } else if (decision.status === 'dropped') {
                        // --- BUG FIX: Mark packet as dropped for visual feedback ---
                        decision.packet.status = 'dropped';
                        // Schedule its removal in 50 ticks to allow it to be seen
                        decision.packet.removalTick = now + 50;
                    }
                }
            });
            renderPackets();
        }

        function startSimulation() {
            if (simulationInterval) clearInterval(simulationInterval);
            simulationInterval = setInterval(simulationTick, parseInt(speedSlider.value, 10));
        }

        function renderPackets() {
            const allPackets = [];
            const now = simulationState.tickCounter;
            simulationState.packetsInTransit.forEach(transit => {
                const sourceNode = nodes.find(n => n.id === transit.packet.path[transit.packet.path.length - 1]);
                const destNode = nodes.find(n => n.id === transit.nextHopId);
                if (!sourceNode || !destNode) return;
                const progress = Math.min((now - transit.departureTime) / (transit.arrivalTime - transit.departureTime), 1.0);
                const x = sourceNode.x + (destNode.x - sourceNode.x) * progress;
                const y = sourceNode.y + (destNode.y - sourceNode.y) * progress;
                allPackets.push({ ...transit.packet, x, y, visualStatus: transit.packet.status === 'dropped' ? 'dropped' : 'transit' });
            });

            const packetsAtRouters = new Map();
            simulationState.activePackets.forEach(packet => {
                const inTransit = simulationState.packetsInTransit.some(t => t.packet.pkt_id === packet.pkt_id);
                if (!inTransit) {
                    const lastHop = packet.path[packet.path.length - 1];
                    if (!packetsAtRouters.has(lastHop)) packetsAtRouters.set(lastHop, []);
                    packetsAtRouters.get(lastHop).push(packet);
                }
            });

            packetsAtRouters.forEach((packets, routerId) => {
                const routerNode = nodes.find(n => n.id === routerId);
                if (!routerNode) return;
                packets.forEach((packet, i) => {
                    const startOffsetX = routerRadius + 5;
                    const startOffsetY = -routerRadius;
                    const step = packetRadius + 2;
                    const x = routerNode.x + startOffsetX + (i * step);
                    const y = routerNode.y + startOffsetY + (i * step);
                    // --- BUG FIX: Correctly identify visual status ---
                    let visualStatus = 'queued';
                    if (packet.status === 'arrived') visualStatus = 'arrived';
                    if (packet.status === 'dropped') visualStatus = 'dropped';
                    allPackets.push({ ...packet, x, y, visualStatus });
                });
            });

            // --- BUG FIX: Add red color for dropped packets ---
            const statusColors = { arrived: '#2ecc71', transit: '#e67e22', queued: '#ff9800', dropped: '#e74c3c' };

            packetElements.selectAll(".packet-group").data(allPackets, d => d.pkt_id)
                .join(
                    enter => {
                        const group = enter.append("g").attr("class", "packet-group");
                        group.append("circle")
                            .attr("r", packetRadius)
                            .attr("stroke", "white");
                        group.append("text")
                             .attr("class", "packet-label")
                             .attr("x", packetRadius + 2)
                             .text(d => d.pkt_id);
                        return group;
                    },
                    update => update,
                    exit => exit.transition().duration(250).attr("opacity", 0).remove() // Fade out dropped packets
                )
                .attr("transform", d => `translate(${d.x}, ${d.y})`)
                .select("circle")
                .attr("fill", d => statusColors[d.visualStatus] || 'grey');
        }

        function updateRouterSelect() {
            const currentSelection = routerSelect.value;
            routerSelect.innerHTML = '';
            const routerIds = nodes.map(n => n.id).sort();
            routerIds.forEach(id => {
                const option = document.createElement('option');
                option.value = id; option.textContent = id;
                routerSelect.appendChild(option);
            });
            if (routerIds.includes(currentSelection)) routerSelect.value = currentSelection;
            updateForwardingTableDisplay();
        }

        function updateForwardingTableDisplay() {
            const router = network.getRouter(routerSelect.value);
            tableDisplay.textContent = router ? JSON.stringify(router.forwardingTable, null, 2) : '{}';
        }

        edgeInput.addEventListener('input', updateNetworkFromInput);
        resetButton.addEventListener('click', resetSimulation);
        speedSlider.addEventListener('input', startSimulation);
        routerSelect.addEventListener('change', updateForwardingTableDisplay);
        packetForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const src = sourceNodeInput.value.trim().toUpperCase();
            const dst = destNodeInput.value.trim().toUpperCase();
            const ttl = parseInt(ttlInput.value, 10);
            const srcRouter = network.getRouter(src);
            if (srcRouter && network.getRouter(dst) && ttl > 0) {
                simulationState.packetCounter++;
                const newId = `P${simulationState.packetCounter}`;
                const packet = new Packet(src, dst, newId, ttl);
                packet.path.push(src);
                srcRouter.receivePacket(packet);
                simulationState.activePackets.set(packet.pkt_id, packet);
                renderPackets();
            } else { alert('Invalid source, destination, or TTL value.'); }
        });

        zoomInBtn.addEventListener('click', () => svg.transition().duration(250).call(zoom.scaleBy, 1.3));
        zoomOutBtn.addEventListener('click', () => svg.transition().duration(250).call(zoom.scaleBy, 1 / 1.3));

        resetSimulation();
        startSimulation();
    });
    </script>
</body>
</html>
